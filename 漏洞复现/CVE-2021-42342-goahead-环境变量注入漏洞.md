# CVE-2021-42342

复现环境：https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2021-42342

## 漏洞原理

针对CVE-2017-17562，该版本对环境变量的名字增加了过滤名单，如下所示：

```c
    envpsize = 64;
    envp = walloc(envpsize * sizeof(char*));
    if (wp->vars) {
        for (n = 0, s = hashFirst(wp->vars); s != NULL; s = hashNext(wp->vars, s)) {
            if (s->content.valid && s->content.type == string) {
                vp = strim(s->name.value.string, 0, WEBS_TRIM_START);
                if (smatch(vp, "REMOTE_HOST") || smatch(vp, "HTTP_AUTHORIZATION") ||
                    smatch(vp, "IFS") || smatch(vp, "CDPATH") ||
                    smatch(vp, "PATH") || sstarts(vp, "LD_")) {
                    continue;
                }
                if (s->arg != 0 && *ME_GOAHEAD_CGI_VAR_PREFIX != '\0') {
                    envp[n++] = sfmt("%s%s=%s", ME_GOAHEAD_CGI_VAR_PREFIX, s->name.value.string,
                        s->content.value.string);
                } else {
                    envp[n++] = sfmt("%s=%s", s->name.value.string, s->content.value.string);
                }
                trace(0, "Env[%d] %s", n, envp[n-1]);
                if (n >= envpsize) {
                    envpsize *= 2;
                    envp = wrealloc(envp, envpsize * sizeof(char *));
                }
            }
        }
    }
    *(envp+n) = NULL;
```



文件上传http数据包：

```http
POST /cgi-bin/hello HTTP/1.1
Host: 10.211.55.34:8081
Content-Length: 299
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: null
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryQlW0Ima0DnR6jdAL
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Connection: close

------WebKitFormBoundaryQlW0Ima0DnR6jdAL
Content-Disposition: form-data; name="hack"

hacker
------WebKitFormBoundaryQlW0Ima0DnR6jdAL
Content-Disposition: form-data; name="file_to_upload"; filename="test.txt"
Content-Type: text/plain

test-file

------WebKitFormBoundaryQlW0Ima0DnR6jdAL--
```

处理body数据的代码主要是在`websProcessUploadData`函数中，在该函数中根据upload的不同状态来调用

```c
PUBLIC bool websProcessUploadData(Webs *wp)
{
    char    *line, *nextTok;
    ssize   nbytes;
    bool    canProceed;

    line = 0;
    canProceed = 1;
    while (canProceed && !wp->finalized && wp->uploadState != UPLOAD_CONTENT_END) {
        if  (wp->uploadState == UPLOAD_BOUNDARY || wp->uploadState == UPLOAD_CONTENT_HEADER) {
            /*
                Parse the next input line
             */
            line = wp->input.servp;
            if ((nextTok = memchr(line, '\n', bufLen(&wp->input))) == 0) {
                /* Incomplete line */
                canProceed = 0;
                break;
            }
            *nextTok++ = '\0';
            nbytes = nextTok - line;
            assert(nbytes > 0);
            websConsumeInput(wp, nbytes);// wp->input.servp = wp->input.servp + nbytes
            strim(line, "\r", WEBS_TRIM_END);
        }
        switch (wp->uploadState) {
        case 0:
            initUpload(wp);
            break;

        case UPLOAD_BOUNDARY:
            processContentBoundary(wp, line);
            break;

        case UPLOAD_CONTENT_HEADER:
            processUploadHeader(wp, line);
            break;

        case UPLOAD_CONTENT_DATA:
            canProceed = processContentData(wp);
            if (bufLen(&wp->input) < wp->boundaryLen) {
                /*  Incomplete boundary - return to get more data */
                canProceed = 0;
            }
            break;

        case UPLOAD_CONTENT_END:
            break;
        }
    }
    bufCompact(&wp->input);
    return canProceed;
}
```

在websProcessUploadData函数下断点，发送上面的请求包，查看wp结构体

```
pwndbg> p *(Webs *)0x555555563690
$1 = {
  rxbuf = {
    buf = 0x5555555654d0 "",
    servp = 0x5555555654d0 "",
    endp = 0x5555555654d0 "",
    endbuf = 0x5555555674d0 "",
    buflen = 8192,
    maxsize = 204804096,
    increment = 8192
  },
  input = {
    buf = 0x555555564cc0 "------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"hack\"\r\n\r\nhacker\r\n------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"file_to_upload\"; filena"...,
    servp = 0x555555564cc0 "------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"hack\"\r\n\r\nhacker\r\n------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"file_to_upload\"; filena"...,
    endp = 0x555555564deb "",
    endbuf = 0x5555555654c0 "",
    buflen = 2048,
    maxsize = 204800001,
    increment = 2048
  },
  output = {
    buf = 0x555555563ca0 "",
    servp = 0x555555563ca0 "",
    endp = 0x555555563ca0 "",
    endbuf = 0x5555555644a0 "",
    buflen = 2048,
    maxsize = 1025,
    increment = 2048
  },
  chunkbuf = {
    buf = 0x5555555644b0 "",
    servp = 0x5555555644b0 "",
    endp = 0x5555555644b0 "",
    endbuf = 0x555555564cb0 "",
    buflen = 2048,
    maxsize = 2048,
    increment = 2048
  },
  txbuf = 0x0,
  since = 0,
  timestamp = 1662363187,
  vars = 10,
  timeout = 0,
  ipaddr = "10.211.55.2", '\000' <repeats 52 times>,
  ifaddr = "10.211.55.34", '\000' <repeats 51 times>,
  rxChunkState = 0,
  rxChunkSize = 0,
  rxEndp = 0x0,
  lastRead = 900,
  eof = 1 '\001',
  txChunkPrefix = '\000' <repeats 15 times>,
  txChunkPrefixNext = 0x0,
  txChunkPrefixLen = 0,
  txChunkLen = 0,
  txChunkState = 0,
  authDetails = 0x0,
  authResponse = 0x0,
  authType = 0x0,
  contentType = 0x5555555679c0 "multipart/form-data; boundary=----WebKitFormBoundaryQlW0Ima0DnR6jdAL",
  cookie = 0x0,
  decodedQuery = 0x0,
  digest = 0x0,
  ext = 0x0,
  filename = 0x55555555db50 "/var/www/goahead/cgi-bin/hello",
  host = 0x555555567660 "10.211.55.34:8081",
  method = 0x5555555675b0 "POST",
  password = 0x0,
  path = 0x555555567640 "/cgi-bin/hello",
  protoVersion = 0x555555567680 "HTTP/1.1",
  protocol = 0x7ffff7f9e55a "http",
  putname = 0x0,
  query = 0x555555567620 "",
  realm = 0x0,
  referrer = 0x0,
  url = 0x555555567600 "/cgi-bin/hello",
  userAgent = 0x555555567a80 "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36",
  username = 0x0,
  sid = 1,
  listenSid = 0,
  port = 8081,
  state = 1,
  flags = 8320,
  code = 200,
  routeCount = 0,
  rxLen = 299,
  rxRemaining = 0,
  txRemaining = 0,
  txLen = -1,
  wid = 0,
  cgiStdin = 0x55555555d910 "/tmp/cgi-0.tmp",
  cgifd = 5,
  putfd = -1,
  docfd = -1,
  written = 0,
  putLen = 0,
  finalized = 0,
  error = 0,
  connError = 0,
  responseCookies = 9,
  session = 0x0,
  route = 0x555555560590,
  user = 0x0,
  writeData = 0x0,
  encoded = 0,
  cnonce = 0x0,
  digestUri = 0x0,
  nonce = 0x0,
  nc = 0x0,
  opaque = 0x0,
  qop = 0x0,
  upfd = -1,
  files = -1,
  boundary = 0x0,
  boundaryLen = 0,
  uploadState = 0,
  currentFile = 0x0,
  clientFilename = 0x0,
  uploadTmp = 0x0,
  uploadVar = 0x0,
  ssl = 0x0
}
```

可以看到wp->uploadState为0，会直接执行initUpload函数，其中会把uploadState字段修改成UPLOAD_BOUNDARY

```c
static void initUpload(Webs *wp)
{
    char    *boundary;

    if (wp->uploadState == 0) {
        wp->uploadState = UPLOAD_BOUNDARY;
        if ((boundary = strstr(wp->contentType, "boundary=")) != 0) {
            boundary += 9;//----WebKitFormBoundaryQlW0Ima0DnR6jdAL
            wfree(wp->boundary);
            wp->boundary = sfmt("--%s", boundary);//------WebKitFormBoundaryQlW0Ima0DnR6jdAL
            wp->boundaryLen = strlen(wp->boundary);//len("------WebKitFormBoundaryQlW0Ima0DnR6jdAL")
        }
        if (wp->boundaryLen == 0 || *wp->boundary == '\0') {
            websError(wp, HTTP_CODE_BAD_REQUEST, "Bad boundary");
        } else {
            websSetVar(wp, "UPLOAD_DIR", uploadDir);//uploadDir: tmp  此处为相对路径，也就是命令行HOME参数指定的，$HOME/tmp
            wp->files = hashCreate(11);
        }
    }
}
```

下载来第二次循环开始：

```c
        if  (wp->uploadState == UPLOAD_BOUNDARY || wp->uploadState == UPLOAD_CONTENT_HEADER) {
            /*
                Parse the next input line
             */
            line = wp->input.servp;
            if ((nextTok = memchr(line, '\n', bufLen(&wp->input))) == 0) {
                /* Incomplete line */
                canProceed = 0;
                break;
            }
            *nextTok++ = '\0';
            nbytes = nextTok - line;
            assert(nbytes > 0);
            websConsumeInput(wp, nbytes);// wp->input.servp = wp->input.servp + nbytes
            strim(line, "\r", WEBS_TRIM_END);//------WebKitFormBoundaryQlW0Ima0DnR6jdAL
        }
```

此时uploadState为UPLOAD_BOUNDARY，会调用processContentBoundary函数，函数会判断body中的multipart boundary和Content-Type是否一致。若一致，会判断当前是否为body的结尾，若不是结尾，则改变uploadState为UPLOAD_CONTENT_HEADER

```c
static void processContentBoundary(Webs *wp, char *line)
{
    /*
        Expecting a multipart boundary string
     */
    if (strncmp(wp->boundary, line, wp->boundaryLen) != 0) {
        websError(wp, HTTP_CODE_BAD_REQUEST, "Bad upload state. Incomplete boundary");

    } else if (line[wp->boundaryLen] && strcmp(&line[wp->boundaryLen], "--") == 0) {//判断multipart结尾 ------WebKitFormBoundaryQlW0Ima0DnR6jdAL--\r\n
        wp->uploadState = UPLOAD_CONTENT_END;

    } else {
        wp->uploadState = UPLOAD_CONTENT_HEADER;
    }
}
```

接着进行第三次循环：

```c
        if  (wp->uploadState == UPLOAD_BOUNDARY || wp->uploadState == UPLOAD_CONTENT_HEADER) {
            /*
                Parse the next input line
             */
            line = wp->input.servp;
            if ((nextTok = memchr(line, '\n', bufLen(&wp->input))) == 0) {
                /* Incomplete line */
                canProceed = 0;
                break;
            }
            *nextTok++ = '\0';
            nbytes = nextTok - line;
            assert(nbytes > 0);
            websConsumeInput(wp, nbytes);// wp->input.servp = wp->input.servp + nbytes
            strim(line, "\r", WEBS_TRIM_END);//Content-Disposition: form-data; name="hack"
        }
```

接着调用processUploadHeader函数，该函数用于处理line变量，比如说，line为`"Content-Disposition: form-data; name="hack"`,该函数会解析字符串，把name的值赋值到wp->uploadVar中

接下载会进行第四次循环，line值为"\0"，如下所示：

![image-20220906092924473](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220906092924473.png)

uploadState的值没有被改变，仍然调用processUploadHeader函数，在该函数开始判断line是否为0，若为0 则将状态改成UPLOAD_CONTENT_DATA，然后退出函数

![image-20220906093015496](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220906093015496.png)

接下来第五次循环，因为uploadState的值为UPLOAD_CONTENT_DATA，所以不会进入到if语句中，也就是不会去处理line

![image-20220906093136591](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220906093136591.png)

在switch中会调用processContentData函数，在该函数下断点，看一下wp结构体的值：

```c
$1 = {
  rxbuf = {
    buf = 0x5555555654d0 "",
    servp = 0x5555555654d0 "",
    endp = 0x5555555654d0 "",
    endbuf = 0x5555555674d0 "",
    buflen = 8192,
    maxsize = 204804096,
    increment = 8192
  },
  input = {
    buf = 0x555555564cc0 "------WebKitFormBoundaryQlW0Ima0DnR6jdAL",
    servp = 0x555555564d19 "hacker\r\n------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"file_to_upload\"; filename=\"test.txt\"\r\nContent-Type: text/plain\r\n\r\ntest-file\n\r\n------WebKitFormBoundaryQlW0Ima0Dn"...,
    endp = 0x555555564deb "",
    endbuf = 0x5555555654c0 "",
    buflen = 2048,
    maxsize = 204800001,
    increment = 2048
  },
  output = {
    buf = 0x555555563ca0 "",
    servp = 0x555555563ca0 "",
    endp = 0x555555563ca0 "",
    endbuf = 0x5555555644a0 "",
    buflen = 2048,
    maxsize = 1025,
    increment = 2048
  },
  chunkbuf = {
    buf = 0x5555555644b0 "",
    servp = 0x5555555644b0 "",
    endp = 0x5555555644b0 "",
    endbuf = 0x555555564cb0 "",
    buflen = 2048,
    maxsize = 2048,
    increment = 2048
  },
  txbuf = 0x0,
  since = 0,
  timestamp = 1662428029,
  vars = 10,
  timeout = 0,
  ipaddr = "10.211.55.2", '\000' <repeats 52 times>,
  ifaddr = "10.211.55.34", '\000' <repeats 51 times>,
  rxChunkState = 0,
  rxChunkSize = 0,
  rxEndp = 0x0,
  lastRead = 900,
  eof = 1 '\001',
  txChunkPrefix = '\000' <repeats 15 times>,
  txChunkPrefixNext = 0x0,
  txChunkPrefixLen = 0,
  txChunkLen = 0,
  txChunkState = 0,
  authDetails = 0x0,
  authResponse = 0x0,
  authType = 0x0,
  contentType = 0x5555555679c0 "multipart/form-data; boundary=----WebKitFormBoundaryQlW0Ima0DnR6jdAL",
  cookie = 0x0,
  decodedQuery = 0x0,
  digest = 0x0,
  ext = 0x0,
  filename = 0x55555555db50 "/var/www/goahead/cgi-bin/hello",
  host = 0x555555567660 "10.211.55.34:8081",
  method = 0x5555555675b0 "POST",
  password = 0x0,
  path = 0x555555567640 "/cgi-bin/hello",
  protoVersion = 0x555555567680 "HTTP/1.1",
  protocol = 0x7ffff7f9e55a "http",
  putname = 0x0,
  query = 0x555555567620 "",
  realm = 0x0,
  referrer = 0x0,
  url = 0x555555567600 "/cgi-bin/hello",
  userAgent = 0x555555567a80 "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36",
  username = 0x0,
  sid = 1,
  listenSid = 0,
  port = 8081,
  state = 1,
  flags = 8320,
  code = 200,
  routeCount = 0,
  rxLen = 299,
  rxRemaining = 0,
  txRemaining = 0,
  txLen = -1,
  wid = 0,
  cgiStdin = 0x55555555d910 "/tmp/cgi-0.tmp",
  cgifd = 5,
  putfd = -1,
  docfd = -1,
  written = 0,
  putLen = 0,
  finalized = 0,
  error = 0,
  connError = 0,
  responseCookies = 9,
  session = 0x0,
  route = 0x555555560590,
  user = 0x0,
  writeData = 0x0,
  encoded = 0,
  cnonce = 0x0,
  digestUri = 0x0,
  nonce = 0x0,
  nc = 0x0,
  opaque = 0x0,
  qop = 0x0,
  upfd = -1,
  files = 11,
  boundary = 0x55555555d720 "------WebKitFormBoundaryQlW0Ima0DnR6jdAL",
  boundaryLen = 40,
  uploadState = 4,
  currentFile = 0x0,
  clientFilename = 0x0,
  uploadTmp = 0x0,
  uploadVar = 0x555555567e30 "hack",
  ssl = 0x0
}
```

processContentData函数的功能在注释已标明

```c
static bool processContentData(Webs *wp)
{
    WebsUpload  *file;
    WebsBuf     *content;
    ssize       size, nbytes, len;
    char        *data, *bp;

    content = &wp->input;
    file = wp->currentFile;

    size = bufLen(content);
    if (size < wp->boundaryLen) {//后去剩余boundary的长度
        /*  Incomplete boundary. Return and get more data */
        return 0;
    }
    if ((bp = getBoundary(wp, content->servp, size)) == 0) {//获取name为hack字段的边界地址
        trace(7, "uploadFilter: Got boundary filename %x", wp->clientFilename);
        if (wp->clientFilename) {
            ......
            return 0;
        }
    }
    data = content->servp;
    nbytes = (bp) ? (bp - data) : bufLen(content);//计算hack字段的长度

    if (nbytes > 0) {
        /*
            This is the CRLF before the boundary
         */
        len = nbytes;
        if (len >= 2 && data[len - 2] == '\r' && data[len - 1] == '\n') {//去除字符串最后两位”\r\n“
            len -= 2;
        }
        if (wp->clientFilename) {
            ......
        } else if (wp->uploadVar) {//这里判断uploadVar是否有值，当前值为hack
            /*
                Normal string form data variables
             */
            data[len] = '\0';//截断，data: hacker
            trace(5, "uploadFilter: form[%s] = %s", wp->uploadVar, data);
            websDecodeUrl(wp->uploadVar, wp->uploadVar, -1);
            websDecodeUrl(data, data, -1);
            websSetVar(wp, wp->uploadVar, data);//把hack字段名和hacker值联系到一起，放入到wp->vars中
        }
        websConsumeInput(wp, nbytes);
    }
    if (wp->clientFilename) {
        /*
            Now have all the data (we've seen the boundary)
         */
        close(wp->upfd);
        wp->upfd = -1;
        wfree(wp->clientFilename);
        wp->clientFilename = 0;
        wfree(wp->uploadTmp);
        wp->uploadTmp = 0;
    }
    wp->uploadState = UPLOAD_BOUNDARY;//改变状态
    return 1;
}
```

第六次循环，进入UPLOAD_BOUNDARY分支，进入到if，line值为”------WebKitFormBoundaryQlW0Ima0DnR6jdAL“

![image-20220906101517947](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220906101517947.png)

调用processContentBoundary函数，判断不是结尾后，改变uploadState为UPLOAD_CONTENT_HEADER，然后进行第七次循环，进入到if语句，line值为”Content-Disposition: form-data; name="file_to_upload"; filename="test.txt"“

调用processUploadHeader函数，wp->uploadVar赋值为file_to_upload，wp->clientFilename赋值为test.txt，然后再$uploadDir下创建一个临时文件切调用open函数打开，将文件描述符存到wp->upfd中

期间会创建一个WebsUpload结构体

```
typedef struct WebsUpload {
    char    *filename;              /**< Local (temp) name of the file    wp->uploadTmp*/
    char    *clientFilename;        /**< Client side name of the file test.txt*/
    char    *contentType;           /**< Content type text/plain*/
    ssize   size;                   /**< Uploaded file size */
} WebsUpload;
```

接着第八次循环，进入if语句，line为“Content-Type: text/plain”，调用UPLOAD_CONTENT_HEADER函数，将WebsUpload->contentType赋值成`text/plain`

第九次循环，line值为0，调用processUploadHeader改变uploadState为UPLOAD_CONTENT_DATA

第十次循环，调用processContentData函数，将文件内容写入到临时文件中，关键代码在writeToFile函数中

```c
    if ((bp = getBoundary(wp, content->servp, size)) == 0) {//获取name为hack字段的边界地址
        trace(7, "uploadFilter: Got boundary filename %x", wp->clientFilename);
        if (wp->clientFilename) {
            /*
                No signature found yet. probably more data to come. Must handle split boundaries.
             */
            data = content->servp;
            nbytes = ((int) (content->endp - data)) - (wp->boundaryLen - 1);
            if (writeToFile(wp, content->servp, nbytes) < 0) {
                /* Proceed to handle error */
                return 1;
            }
            websConsumeInput(wp, nbytes);
            /* Get more data */
            return 0;
        }
    }
```

至此文件上传的过程已经分析结束，可以得到可以通过multipart方法向wp->vars中添加键值对

看一下该版本是如何操作envp数组的，很明显多了几个黑名单

```c
    envpsize = 64;
    envp = walloc(envpsize * sizeof(char*));
    if (wp->vars) {
        for (n = 0, s = hashFirst(wp->vars); s != NULL; s = hashNext(wp->vars, s)) {
            if (s->content.valid && s->content.type == string) {
                vp = strim(s->name.value.string, 0, WEBS_TRIM_START);
                if (smatch(vp, "REMOTE_HOST") || smatch(vp, "HTTP_AUTHORIZATION") ||
                    smatch(vp, "IFS") || smatch(vp, "CDPATH") ||
                    smatch(vp, "PATH") || sstarts(vp, "LD_")) {
                    continue;
                }
                ......
            }
        }
    }
    *(envp+n) = NULL;
```

vp指针是通过调用strim函数得到的，如果第一个参数或者第二个参数是0，那么函数会直接返回0，调用该函数时，第二个参数为0 ，所以vp恒为0，过滤不起作用

```c
PUBLIC char *strim(char *str, cchar *set, int where)
{
    char    *s;
    ssize   len, i;

    if (str == 0 || set == 0) {
        return 0;
    }
    if (where & WEBS_TRIM_START) {
        i = strspn(str, set);
    } else {
        i = 0;
    }
    s = (char*) &str[i];
    if (where & WEBS_TRIM_END) {
        len = strlen(s);
        while (len > 0 && strspn(&s[len - 1], set) > 0) {
            s[len - 1] = '\0';
            len--;
        }
    }
    return s;
}
```

接着会根据两个变量的值决定是否给参数添加前缀，一个是`s->arg`，另一个是ME_GOAHEAD_CGI_VAR_PREFIX 。

```c
                if (s->arg != 0 && *ME_GOAHEAD_CGI_VAR_PREFIX != '\0') {
                    envp[n++] = sfmt("%s%s=%s", ME_GOAHEAD_CGI_VAR_PREFIX, s->name.value.string,
                        s->content.value.string);
                } else {
                    envp[n++] = sfmt("%s=%s", s->name.value.string, s->content.value.string);
                }
                trace(0, "Env[%d] %s", n, envp[n-1]);
                if (n >= envpsize) {
                    envpsize *= 2;
                    envp = wrealloc(envp, envpsize * sizeof(char *));
                }
```

其中s->arg是初始值为0，如果有get传参的话，就会设为1，ME_GOAHEAD_CGI_VAR_PREFIX初始化为“CGI_”

漏洞就在于我们可以通过multipart来向vars中添加键值对，不用get传参的话s->arg仍为初始值0，那么就不会进入到if中，在else中就不会给变量加上前缀，造成任意环境变量注入。



接瞎子啊就是劫持LD_PRELOAD到可控的文件上去，我们上传的文件会在$home/tmp目录下生成一个临时文件，修改cgi-bin/hello

```c
#!/bin/bash

echo -e "Content-Type: text/plain\n"
echo -e "my demo\n"
ls -al /root/goahead/src/tmp/
ls -al /proc/self/fd/
env

```

发现执行cgi的时候上传文件的临时文件描述符已经关闭了

![image-20220906111834150](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220906111834150.png)

解决办法就是在文件末尾添加垃圾字节（不影响exp.so的运行），使write函数执行时间拉长



最终效果如下所示

![image-20220906112142189](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220906112142189.png)

