# CVE-2021-42342

复现环境：https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2021-42342

## 漏洞原理

针对CVE-2017-17562，该版本对环境变量的名字增加了过滤名单，如下所示：

```c
    envpsize = 64;
    envp = walloc(envpsize * sizeof(char*));
    if (wp->vars) {
        for (n = 0, s = hashFirst(wp->vars); s != NULL; s = hashNext(wp->vars, s)) {
            if (s->content.valid && s->content.type == string) {
                vp = strim(s->name.value.string, 0, WEBS_TRIM_START);
                if (smatch(vp, "REMOTE_HOST") || smatch(vp, "HTTP_AUTHORIZATION") ||
                    smatch(vp, "IFS") || smatch(vp, "CDPATH") ||
                    smatch(vp, "PATH") || sstarts(vp, "LD_")) {
                    continue;
                }
                if (s->arg != 0 && *ME_GOAHEAD_CGI_VAR_PREFIX != '\0') {
                    envp[n++] = sfmt("%s%s=%s", ME_GOAHEAD_CGI_VAR_PREFIX, s->name.value.string,
                        s->content.value.string);
                } else {
                    envp[n++] = sfmt("%s=%s", s->name.value.string, s->content.value.string);
                }
                trace(0, "Env[%d] %s", n, envp[n-1]);
                if (n >= envpsize) {
                    envpsize *= 2;
                    envp = wrealloc(envp, envpsize * sizeof(char *));
                }
            }
        }
    }
    *(envp+n) = NULL;
```



文件上传http数据包：

```http
POST /cgi-bin/hello HTTP/1.1
Host: 10.211.55.34:8081
Content-Length: 299
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: null
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryQlW0Ima0DnR6jdAL
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Connection: close

------WebKitFormBoundaryQlW0Ima0DnR6jdAL
Content-Disposition: form-data; name="hack"

hacker
------WebKitFormBoundaryQlW0Ima0DnR6jdAL
Content-Disposition: form-data; name="file_to_upload"; filename="test.txt"
Content-Type: text/plain

test-file

------WebKitFormBoundaryQlW0Ima0DnR6jdAL--
```

处理body数据的代码主要是在`websProcessUploadData`函数中，在该函数中根据upload的不同状态来调用

```c
PUBLIC bool websProcessUploadData(Webs *wp)
{
    char    *line, *nextTok;
    ssize   nbytes;
    bool    canProceed;

    line = 0;
    canProceed = 1;
    while (canProceed && !wp->finalized && wp->uploadState != UPLOAD_CONTENT_END) {
        if  (wp->uploadState == UPLOAD_BOUNDARY || wp->uploadState == UPLOAD_CONTENT_HEADER) {
            /*
                Parse the next input line
             */
            line = wp->input.servp;
            if ((nextTok = memchr(line, '\n', bufLen(&wp->input))) == 0) {
                /* Incomplete line */
                canProceed = 0;
                break;
            }
            *nextTok++ = '\0';
            nbytes = nextTok - line;
            assert(nbytes > 0);
            websConsumeInput(wp, nbytes);// wp->input.servp = wp->input.servp + nbytes
            strim(line, "\r", WEBS_TRIM_END);
        }
        switch (wp->uploadState) {
        case 0:
            initUpload(wp);
            break;

        case UPLOAD_BOUNDARY:
            processContentBoundary(wp, line);
            break;

        case UPLOAD_CONTENT_HEADER:
            processUploadHeader(wp, line);
            break;

        case UPLOAD_CONTENT_DATA:
            canProceed = processContentData(wp);
            if (bufLen(&wp->input) < wp->boundaryLen) {
                /*  Incomplete boundary - return to get more data */
                canProceed = 0;
            }
            break;

        case UPLOAD_CONTENT_END:
            break;
        }
    }
    bufCompact(&wp->input);
    return canProceed;
}
```

在websProcessUploadData函数下断点，发送上面的请求包，查看wp结构体

```
pwndbg> p *(Webs *)0x555555563690
$1 = {
  rxbuf = {
    buf = 0x5555555654d0 "",
    servp = 0x5555555654d0 "",
    endp = 0x5555555654d0 "",
    endbuf = 0x5555555674d0 "",
    buflen = 8192,
    maxsize = 204804096,
    increment = 8192
  },
  input = {
    buf = 0x555555564cc0 "------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"hack\"\r\n\r\nhacker\r\n------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"file_to_upload\"; filena"...,
    servp = 0x555555564cc0 "------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"hack\"\r\n\r\nhacker\r\n------WebKitFormBoundaryQlW0Ima0DnR6jdAL\r\nContent-Disposition: form-data; name=\"file_to_upload\"; filena"...,
    endp = 0x555555564deb "",
    endbuf = 0x5555555654c0 "",
    buflen = 2048,
    maxsize = 204800001,
    increment = 2048
  },
  output = {
    buf = 0x555555563ca0 "",
    servp = 0x555555563ca0 "",
    endp = 0x555555563ca0 "",
    endbuf = 0x5555555644a0 "",
    buflen = 2048,
    maxsize = 1025,
    increment = 2048
  },
  chunkbuf = {
    buf = 0x5555555644b0 "",
    servp = 0x5555555644b0 "",
    endp = 0x5555555644b0 "",
    endbuf = 0x555555564cb0 "",
    buflen = 2048,
    maxsize = 2048,
    increment = 2048
  },
  txbuf = 0x0,
  since = 0,
  timestamp = 1662363187,
  vars = 10,
  timeout = 0,
  ipaddr = "10.211.55.2", '\000' <repeats 52 times>,
  ifaddr = "10.211.55.34", '\000' <repeats 51 times>,
  rxChunkState = 0,
  rxChunkSize = 0,
  rxEndp = 0x0,
  lastRead = 900,
  eof = 1 '\001',
  txChunkPrefix = '\000' <repeats 15 times>,
  txChunkPrefixNext = 0x0,
  txChunkPrefixLen = 0,
  txChunkLen = 0,
  txChunkState = 0,
  authDetails = 0x0,
  authResponse = 0x0,
  authType = 0x0,
  contentType = 0x5555555679c0 "multipart/form-data; boundary=----WebKitFormBoundaryQlW0Ima0DnR6jdAL",
  cookie = 0x0,
  decodedQuery = 0x0,
  digest = 0x0,
  ext = 0x0,
  filename = 0x55555555db50 "/var/www/goahead/cgi-bin/hello",
  host = 0x555555567660 "10.211.55.34:8081",
  method = 0x5555555675b0 "POST",
  password = 0x0,
  path = 0x555555567640 "/cgi-bin/hello",
  protoVersion = 0x555555567680 "HTTP/1.1",
  protocol = 0x7ffff7f9e55a "http",
  putname = 0x0,
  query = 0x555555567620 "",
  realm = 0x0,
  referrer = 0x0,
  url = 0x555555567600 "/cgi-bin/hello",
  userAgent = 0x555555567a80 "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36",
  username = 0x0,
  sid = 1,
  listenSid = 0,
  port = 8081,
  state = 1,
  flags = 8320,
  code = 200,
  routeCount = 0,
  rxLen = 299,
  rxRemaining = 0,
  txRemaining = 0,
  txLen = -1,
  wid = 0,
  cgiStdin = 0x55555555d910 "/tmp/cgi-0.tmp",
  cgifd = 5,
  putfd = -1,
  docfd = -1,
  written = 0,
  putLen = 0,
  finalized = 0,
  error = 0,
  connError = 0,
  responseCookies = 9,
  session = 0x0,
  route = 0x555555560590,
  user = 0x0,
  writeData = 0x0,
  encoded = 0,
  cnonce = 0x0,
  digestUri = 0x0,
  nonce = 0x0,
  nc = 0x0,
  opaque = 0x0,
  qop = 0x0,
  upfd = -1,
  files = -1,
  boundary = 0x0,
  boundaryLen = 0,
  uploadState = 0,
  currentFile = 0x0,
  clientFilename = 0x0,
  uploadTmp = 0x0,
  uploadVar = 0x0,
  ssl = 0x0
}
```

可以看到wp->uploadState为0，会直接执行initUpload函数，其中会把uploadState字段修改成UPLOAD_BOUNDARY

```c
static void initUpload(Webs *wp)
{
    char    *boundary;

    if (wp->uploadState == 0) {
        wp->uploadState = UPLOAD_BOUNDARY;
        if ((boundary = strstr(wp->contentType, "boundary=")) != 0) {
            boundary += 9;//----WebKitFormBoundaryQlW0Ima0DnR6jdAL
            wfree(wp->boundary);
            wp->boundary = sfmt("--%s", boundary);//------WebKitFormBoundaryQlW0Ima0DnR6jdAL
            wp->boundaryLen = strlen(wp->boundary);//len("------WebKitFormBoundaryQlW0Ima0DnR6jdAL")
        }
        if (wp->boundaryLen == 0 || *wp->boundary == '\0') {
            websError(wp, HTTP_CODE_BAD_REQUEST, "Bad boundary");
        } else {
            websSetVar(wp, "UPLOAD_DIR", uploadDir);//uploadDir: tmp  此处为相对路径，也就是命令行HOME参数指定的，$HOME/tmp
            wp->files = hashCreate(11);
        }
    }
}
```

下载来第二次循环开始：

```c
        if  (wp->uploadState == UPLOAD_BOUNDARY || wp->uploadState == UPLOAD_CONTENT_HEADER) {
            /*
                Parse the next input line
             */
            line = wp->input.servp;
            if ((nextTok = memchr(line, '\n', bufLen(&wp->input))) == 0) {
                /* Incomplete line */
                canProceed = 0;
                break;
            }
            *nextTok++ = '\0';
            nbytes = nextTok - line;
            assert(nbytes > 0);
            websConsumeInput(wp, nbytes);// wp->input.servp = wp->input.servp + nbytes
            strim(line, "\r", WEBS_TRIM_END);//------WebKitFormBoundaryQlW0Ima0DnR6jdAL
        }
```

此时uploadState为UPLOAD_BOUNDARY，会调用processContentBoundary函数，函数会判断body中的multipart boundary和Content-Type是否一致。若一致，会判断当前是否为body的结尾，若不是结尾，则改变uploadState为UPLOAD_CONTENT_HEADER

```c
static void processContentBoundary(Webs *wp, char *line)
{
    /*
        Expecting a multipart boundary string
     */
    if (strncmp(wp->boundary, line, wp->boundaryLen) != 0) {
        websError(wp, HTTP_CODE_BAD_REQUEST, "Bad upload state. Incomplete boundary");

    } else if (line[wp->boundaryLen] && strcmp(&line[wp->boundaryLen], "--") == 0) {//判断multipart结尾 ------WebKitFormBoundaryQlW0Ima0DnR6jdAL--\r\n
        wp->uploadState = UPLOAD_CONTENT_END;

    } else {
        wp->uploadState = UPLOAD_CONTENT_HEADER;
    }
}
```

接着进行第三次循环：

```c
        if  (wp->uploadState == UPLOAD_BOUNDARY || wp->uploadState == UPLOAD_CONTENT_HEADER) {
            /*
                Parse the next input line
             */
            line = wp->input.servp;
            if ((nextTok = memchr(line, '\n', bufLen(&wp->input))) == 0) {
                /* Incomplete line */
                canProceed = 0;
                break;
            }
            *nextTok++ = '\0';
            nbytes = nextTok - line;
            assert(nbytes > 0);
            websConsumeInput(wp, nbytes);// wp->input.servp = wp->input.servp + nbytes
            strim(line, "\r", WEBS_TRIM_END);//Content-Disposition: form-data; name="hack"
        }
```

接着调用processUploadHeader函数

```
```

